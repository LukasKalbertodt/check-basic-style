import * as core from "@actions/core";
import * as glob from "glob";
import * as fs from "fs/promises";


// ====== Main functions =========================================================================

const main = async () => {
    const config = new Config();

    // Collect paths.
    const paths = new Set<string>();
    for (const pattern of config.files) {
        glob.sync(pattern, { nodir: true }).forEach(m => {
            if (!config.checkGeneratedFiles && IGNORED_FILES.some(ignored => m.endsWith(ignored))) {
                core.debug(`Will ignore autogenerated file: ${m}`);
            } else {
                paths.add(m);
            }
        });
    }

    core.debug(`Will check these files: \n${Array.from(paths).map(p => `- ${p}`).join("\n")}`);

    // Run check for each path.
    const filesWithProblems = [];
    for (const path of paths) {
        const outcome = await checkFile(path, config);
        if (outcome === "error") {
            filesWithProblems.push(path);
        }
    }

    const heading = "Basic style check results"
    if (filesWithProblems.length === 0) {
        await core.summary
            .addHeading(heading)
            .addRaw("✅ All files passed all tests!")
            .write();
    } else {
        core.setFailed("Some problems were found");
        await core.summary
            .addHeading(heading)
            .addRaw("❌ Problems were found in these files:")
            .addList(filesWithProblems)
            .write();
    }
};

/** Files that are almost always autogenerated and are thus ignored by default. */
const IGNORED_FILES = ["Cargo.lock", "package-lock.json", "yarn.lock"];

class Config {
    files: string[];
    checkGeneratedFiles: boolean;
    assertSingleTrailingNewline: boolean;
    assertNoTrailingWhitespace: boolean;
    maxLineLen: number;
    allowLongLinesWithUrls: boolean;
    disallowTabs: boolean;

    constructor() {
        this.files = core.getMultilineInput("files");
        this.checkGeneratedFiles = core.getBooleanInput("check_generated_files");
        this.assertSingleTrailingNewline = core.getBooleanInput("assert_single_trailing_newline");
        this.assertNoTrailingWhitespace = core.getBooleanInput("assert_no_trailing_whitespace");
        this.maxLineLen = Number(core.getInput("max_line_len") || 100);
        this.allowLongLinesWithUrls = core.getBooleanInput("allow_long_lines_with_urls");
        this.disallowTabs = core.getBooleanInput("disallow_tabs");
    }
}

type Outcome = "error" | "ok";

type ReportError = (title: string, note: string, line?: number) => "error";


const utf8Decoder = new TextDecoder("utf8", { fatal: true });

const checkFile = async (path: string, config: Config): Promise<Outcome> => {
    const reportError: ReportError = (msg, note, line) => {
        core.error(note, {
            file: path,
            title: msg,
            startLine: line,
        });

        // We print an additional error to the terminal so that the action log
        // contains all necessary information without forcing us to put
        // superfluous information in the annotation text.
        console.error(`Problem in '${path}${line == null ? "" : `:${line}`}': ${msg} (${note})`);

        return "error";
    };

    const content = await fs.readFile(path);

    // We always make sure the file is UTF-8 so that checks can operate on a
    // string instead of a byte buffer.
    let str;
    try {
        str = utf8Decoder.decode(content);
    } catch (e) {
        return reportError("Not UTF-8 encoded", "File is not encoded as valid UTF-8");
    }

    // Our second always-on/mandatory check is for unix line endings. Other
    // checks can be way simpler if they can assume Unix line endings.
    const index = str.indexOf("\r");
    if (index !== -1) {
        const line = [...str.substring(0, index)].filter(c => c === "\n").length + 1;
        return reportError(
            "Non-Unix line ending ('\\r') found",
            "'\\r' character found, should only use Unix line endings ('\\n') instead",
            line,
        );
    }


    const outcomes = [];
    if (config.assertSingleTrailingNewline) {
        outcomes.push(checkSingleTrailingNewline(str, reportError));
    }
    if (config.assertNoTrailingWhitespace) {
        outcomes.push(checkTrailingWhitespace(str, reportError));
    }
    if (config.maxLineLen != -1) {
        outcomes.push(
            checkLineLength(str, config.maxLineLen, config.allowLongLinesWithUrls, reportError)
        );
    }
    if (config.disallowTabs) {
        outcomes.push(checkTabs(str, reportError));
    }

    return outcomes.every(outcome => outcome === "ok") ? "ok" : "error";
};


// ====== Individual checks ======================================================================

const checkSingleTrailingNewline = (content: string, error: ReportError): Outcome => {
    // Empty files are allowed to have no newlines.
    if (content.length === 0) {
        return "ok";
    }

    const numNewlines = () => [...content].filter(c => c === "\n").length;
    if (content[content.length - 1] !== "\n") {
        return error(`Missing trailing newline`,
            "File does not end with newline",
            numNewlines() + 1,
        );
    }

    // We want a _single_ trailing newline, if there is more than one byte in
    // this file.
    if (content.length > 1 && content[content.length - 2] === "\n") {
        return error("Multiple trailing newlines",
            "File contains more than one newline at the end",
            numNewlines() + 1,
        );
    }

    return "ok";
};

const checkTrailingWhitespace = (content: string, error: ReportError): Outcome => {
    let outcome: Outcome = "ok";
    content.split("\n").forEach((line, i) => {
        if (line.length !== line.trimEnd().length) {
            error(
                "Line with trailing whitespace",
                "Line ends with whitespace characters which should be removed",
                i + 1,
            );
            outcome = "error";
        }
    });

    return outcome;
};

const checkLineLength = (
    content: string,
    limit: number,
    allowUrls: boolean,
    error: ReportError,
): Outcome => {
    let outcome: Outcome = "ok";
    content.split("\n").forEach((line, i) => {
        // This counts the number of Unicode code points.
        const len = [...line].length;

        // This is obviously not a spec-complient URL detector. This is just
        // a rough approximation.
        const tooLong = len > limit
            && !(allowUrls && /(http|ftp|https):\/\/[\w-]+(\.[\w-]+)+/.test(line));

        if (tooLong) {
            error(
                "Line too long",
                `Line exceeds maximum length of ${limit} (it's ${len} Unicode codepoints long)`,
                i + 1,
            );
            outcome = "error";
        }
    });

    return outcome;
};

const checkTabs = (content: string, error: ReportError): Outcome => {
    let outcome: Outcome = "ok";
    content.split("\n").forEach((line, i) => {
        if (line.includes("\t")) {
            error(
                "Tab character found",
                "Tab characters ('\\t') are not allowed, indent with spaces instead",
                i + 1,
            );
            outcome = "error";
        }
    });

    return outcome;
}


// ====== Calling entry point ====================================================================

main()
    .catch(err => core.setFailed(`An error occured: ${err}`))
    .then(() => core.debug("Done"));
